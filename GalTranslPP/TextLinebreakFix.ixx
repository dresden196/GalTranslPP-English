module;

#include <spdlog/spdlog.h>
#include <toml.hpp>

export module TextLinebreakFix;

import Tool;
import PythonManager;
export import IPlugin;

namespace fs = std::filesystem;

export {

	enum class LinebreakFixMode
	{
		None, Average, FixCharCount, KeepPositions, PreferPunctations
	};

	class TextLinebreakFix : public IPlugin {

	private:

		LinebreakFixMode m_mode;
		int m_segmentThreshold;
		int m_errorThreshold;
		bool m_forceFix;
		bool m_useTokenizer;
		bool m_needReboot = false;
		double m_priorityThreshold = 0.2;

		std::function<NLPResult(const std::string&)> m_tokenizeTargetLangFunc;
		std::vector<std::string> splitIntoTokens(const std::string& text);

	public:

		TextLinebreakFix(const fs::path& projectDir, const toml::value& projectConfig, std::shared_ptr<spdlog::logger> logger);

		virtual bool needReboot() override { return m_needReboot; }

		virtual void run(Sentence* se) override;

		virtual ~TextLinebreakFix() override = default;
	};
}


module :private;

TextLinebreakFix::TextLinebreakFix(const fs::path& projectDir, const toml::value& projectConfig, std::shared_ptr<spdlog::logger> logger)
	: IPlugin(projectDir, logger)
{
	try {
		const auto pluginConfig = toml::parse(pluginConfigsPath / L"textPostPlugins/TextLinebreakFix.toml");

		std::string linebreakMode = parseToml<std::string>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.换行模式");
		if (linebreakMode == "平均") {
			m_mode = LinebreakFixMode::Average;
		}
		else if (linebreakMode == "固定字数") {
			m_mode = LinebreakFixMode::FixCharCount;
		}
		else if (linebreakMode == "保留位置") {
			m_mode = LinebreakFixMode::KeepPositions;
		}
		else if (linebreakMode == "优先标点") {
			m_mode = LinebreakFixMode::PreferPunctations;
		}
		else {
			throw std::invalid_argument("TextLinebreakFix 无效的换行模式: " + linebreakMode);
		}
		m_priorityThreshold = parseToml<double>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.优先阈值");
		m_segmentThreshold = parseToml<int>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.分段字数阈值");
		m_forceFix = parseToml<bool>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.强制修复");
		m_errorThreshold = parseToml<int>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.报错阈值");
		m_useTokenizer = parseToml<bool>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.使用分词器");


		if (m_useTokenizer) {
			const std::string& tokenizerBackend = parseToml<std::string>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.tokenizerBackend");
			if (tokenizerBackend == "MeCab") {
				const std::string& mecabDictDir = parseToml<std::string>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.mecabDictDir");
				m_logger->info("TextLinebreakFix 正在检查 MeCab 环境...");
				m_tokenizeTargetLangFunc = getMeCabTokenizeFunc(mecabDictDir, m_logger);
				m_logger->info("TextLinebreakFix MeCab 环境检查完毕。");
			}
			else if (tokenizerBackend == "spaCy") {
				const std::string& spaCyModelName = parseToml<std::string>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.spaCyModelName");
				m_logger->info("TextLinebreakFix 正在检查 spaCy 环境...");
				m_tokenizeTargetLangFunc = getNLPTokenizeFunc({ "spacy" }, "tokenizer_spacy", spaCyModelName, m_needReboot, m_logger);
				m_logger->info("TextLinebreakFix spaCy 环境检查完毕。");
			}
			else if (tokenizerBackend == "Stanza") {
				const std::string& stanzaLang = parseToml<std::string>(projectConfig, pluginConfig, "plugins.TextLinebreakFix.stanzaLang");
				m_logger->info("TextLinebreakFix 正在检查 Stanza 环境...");
				m_tokenizeTargetLangFunc = getNLPTokenizeFunc({ "stanza" }, "tokenizer_stanza", stanzaLang, m_needReboot, m_logger);
				m_logger->info("TextLinebreakFix Stanza 环境检查完毕。");
			}
			else {
				throw std::invalid_argument("TextLinebreakFix 无效的 tokenizerBackend");
			}
		}

		if (m_segmentThreshold <= 0) {
			throw std::runtime_error("TextLinebreakFix 分段字数阈值必须大于0");
		}
		if (m_errorThreshold <= 0) {
			throw std::runtime_error("TextLinebreakFix 报错阈值必须大于0");
		}

		m_logger->info("已加载插件 TextLinebreakFix, 换行模式: {}, 优先阈值 {:.2f}, 分段字数阈值: {}, 强制修复: {}, 报错阈值: {}",
			linebreakMode, m_priorityThreshold, m_segmentThreshold, m_forceFix, m_errorThreshold);
		if (m_useTokenizer) {
			m_logger->info("插件 TextLinebreakFix 分词器已启用");
		}
	}
	catch (const toml::exception& e) {
		m_logger->critical("换行修复配置文件解析错误");
		throw std::runtime_error(e.what());
	}
}

std::vector<std::string> TextLinebreakFix::splitIntoTokens(const std::string& text)
{
	std::vector<std::string> tokens;
	NLPResult result = m_tokenizeTargetLangFunc(text);
	const WordPosVec& wordPosList = std::get<0>(result);
	for (const auto& wordPos : wordPosList) {
		tokens.push_back(wordPos.front());
	}
	return tokens;
}

void TextLinebreakFix::run(Sentence* se)
{
	int origLinebreakCount = countSubstring(se->pre_processed_text, "<br>");
	int transLinebreakCount = countSubstring(se->translated_preview, "<br>");

	if (transLinebreakCount == origLinebreakCount && !m_forceFix) {
		return;
	}

	m_logger->debug("需要修复换行的句子[{}]: 原文 {} 行, 译文 {} 行", se->pre_processed_text, origLinebreakCount + 1, transLinebreakCount + 1);

	std::string origTransPreview = se->translated_preview;
	std::string transViewToModify = se->translated_preview;
	replaceStrInplace(transViewToModify, "<br>", "");
	if (transViewToModify.empty()) {
		for (int i = 0; i < origLinebreakCount; i++) {
			transViewToModify += "<br>";
		}
		se->translated_preview = transViewToModify;

		se->other_info["换行修复"] = std::format("原文 {} 行, 译文 {} 行, 修正后 {} 行", origLinebreakCount + 1, transLinebreakCount + 1, transLinebreakCount + 1);
		m_logger->debug("译文[{}]({}行): 修正后译文[{}]({}行)", origTransPreview, origLinebreakCount + 1, se->translated_preview, transLinebreakCount + 1);
		return;
	}

	switch (m_mode) {
	case LinebreakFixMode::Average:
	{
		std::vector<std::string> tokens = m_useTokenizer ? splitIntoTokens(transViewToModify) : splitIntoGraphemes(transViewToModify);
		size_t totalCharCount = countGraphemes(transViewToModify);
		int linebreakAdded = 0;

		size_t charCountLine = totalCharCount / (origLinebreakCount + 1);
		if (charCountLine == 0) {
			charCountLine = 1;
		}

		transViewToModify.clear();
		for (size_t i = 0; i < tokens.size(); i++) {
			transViewToModify += tokens[i];
			if ((i + 1) % charCountLine == 0 && linebreakAdded < origLinebreakCount) {
				transViewToModify += "<br>";
				linebreakAdded++;
			}
		}
	}
	break;
	case LinebreakFixMode::FixCharCount:
	{
		std::vector<std::string> graphemes = splitIntoGraphemes(transViewToModify);
		transViewToModify.clear();
		for (size_t i = 0; i < graphemes.size(); i++) {
			transViewToModify += graphemes[i];
			if ((i + 1) % m_segmentThreshold == 0 && i != graphemes.size() - 1) {
				transViewToModify += "<br>";
			}
		}
	}
	break;
	case LinebreakFixMode::KeepPositions:
	{
		std::vector<std::string> tokens = m_useTokenizer ? splitIntoTokens(transViewToModify) : splitIntoGraphemes(transViewToModify);
		std::vector<double> relLinebreakPositions = getSubstringPositions(se->pre_processed_text, "<br>");
		std::vector<size_t> positionsToAddLinebreak; // 最终要在 transViewToModify 中插入换行符的位置

		size_t currentPos = 0;
		size_t currentTokenIndex = 0;
		for (const auto& relLinebreakPos : relLinebreakPositions) {
			while (currentPos / (double)transViewToModify.length() < relLinebreakPos) {
				currentPos += tokens[currentTokenIndex].length();
				currentTokenIndex++;
			}
			positionsToAddLinebreak.push_back(currentPos);
		}

		for (const auto& posToAddLinebreak : positionsToAddLinebreak | std::views::reverse) {
			transViewToModify.insert(posToAddLinebreak, "<br>");
		}
	}
	break;
	case LinebreakFixMode::PreferPunctations:
	{
		std::vector<std::string> graphemes = splitIntoGraphemes(transViewToModify);
		std::vector<std::string> tokens = m_useTokenizer ? splitIntoTokens(transViewToModify) : graphemes;
		static const std::set<std::string> excludePuncts =
		{ "『", "「", "“", "‘", "'", "《", "〈", "（", "【", "〔", "〖" };

		// 预处理标点信息，获取所有可以添加换行的标点位置
		std::vector<double> relLinebreakPositions = getSubstringPositions(se->pre_processed_text, "<br>");

		struct PunctInfo
		{
			size_t prePos;
			size_t postPos;
			double relPos;
		};
		std::vector<PunctInfo> punctPositions;
		size_t currentPos = 0;
		for (size_t i = 0; i < graphemes.size(); i++) {
			currentPos += graphemes[i].length();
			if (removePunctuation(graphemes[i]).empty()) {
				punctPositions.push_back({ currentPos - graphemes[i].length(), currentPos, currentPos / (double)transViewToModify.length() });
			}
			// 如果当前字符的后一个字符是空白字符或如上左边界字符，则把当前字符作为标点对待
			else if (
				i + 1 < graphemes.size() && 
				(removeWhitespace(graphemes[i + 1]).empty() || excludePuncts.contains(graphemes[i + 1]))
				) {
				punctPositions.push_back({ currentPos - graphemes[i].length(), currentPos, currentPos / (double)transViewToModify.length() });
			}
		}
		std::erase_if(punctPositions, [&](PunctInfo& pos)
			{
				if (pos.postPos >= transViewToModify.length()) {
					return true;
				}
				std::string punctStr = transViewToModify.substr(pos.prePos, pos.postPos - pos.prePos);
				// 不在这些标点后添加换行符
				if (excludePuncts.contains(punctStr)) {
					return true;
				}
				// 如果标点后面还有标点，则不插入换行符
				return std::ranges::any_of(punctPositions, [&](auto& otherPos)
					{
						return pos.postPos == otherPos.prePos;
					});
			});

		std::vector<size_t> positionsToAddLinebreak; // 最终要在 transViewToModify 中插入换行符的位置
		// 预处理信息完毕


		if (origLinebreakCount <= (int)punctPositions.size()) {
			currentPos = 0;
			size_t currentTokenIndex = 0;
			// 换行挑标点
			std::vector<PunctInfo> filteredPunctPositions; // 被挑出来的标点位置
			for (const auto& relLinebreakPos : relLinebreakPositions) {
				auto it = std::ranges::min_element(punctPositions, [&](const auto& a, const auto& b)
					{
						return calculateAbs(a.relPos, relLinebreakPos)
							< calculateAbs(b.relPos, relLinebreakPos);
					});
				filteredPunctPositions.push_back(*it);
				punctPositions.erase(it);
			}
			std::ranges::sort(filteredPunctPositions, [](const auto& a, const auto& b)
				{
					return a.prePos < b.prePos;
				});
			for (const auto& [index, punctPos] : filteredPunctPositions | std::views::enumerate) {
				if (double relLinebreakPos = relLinebreakPositions[index];  calculateAbs(punctPos.relPos, relLinebreakPos) > m_priorityThreshold) {
					while (currentPos / (double)transViewToModify.length() < relLinebreakPositions[index]) {
						currentPos += tokens[currentTokenIndex].length();
						currentTokenIndex++;
					}
					positionsToAddLinebreak.push_back(currentPos);
				}
				else {
					positionsToAddLinebreak.push_back(punctPos.postPos);
				}
			}
		}
		else {
			currentPos = 0;
			size_t currentTokenIndex = 0;
			// 标点挑换行
			std::vector<double> filteredRelLinebreakPositions; // 被挑出来的换行位置
			for (const auto& punctPos : punctPositions) {
				auto it = std::ranges::min_element(relLinebreakPositions, [&](const auto& a, const auto& b)
					{
						return calculateAbs(a, punctPos.relPos)
							< calculateAbs(b, punctPos.relPos);
					});
				filteredRelLinebreakPositions.push_back(*it);
				relLinebreakPositions.erase(it);
			}
			std::ranges::sort(filteredRelLinebreakPositions);
			for (const auto& [index, relLinebreakPos] : filteredRelLinebreakPositions | std::views::enumerate) {
				if (double punctPos = punctPositions[index].relPos;  calculateAbs(relLinebreakPos, punctPos) > m_priorityThreshold) {
					while (currentPos / (double)transViewToModify.length() < relLinebreakPos) {
						currentPos += tokens[currentTokenIndex].length();
						currentTokenIndex++;
					}
					positionsToAddLinebreak.push_back(currentPos);
				}
				else {
					positionsToAddLinebreak.push_back(punctPositions[index].postPos);
				}
			}
			currentPos = 0;
			currentTokenIndex = 0;
			for (const auto& relLinebreakPos : relLinebreakPositions) {
				while (currentPos / (double)transViewToModify.length() < relLinebreakPos) {
					currentPos += tokens[currentTokenIndex].length();
					currentTokenIndex++;
				}
				positionsToAddLinebreak.push_back(currentPos);
			}
		}

		std::ranges::sort(positionsToAddLinebreak);

		for (const auto& posToAddLinebreak : positionsToAddLinebreak | std::views::reverse) {
			transViewToModify.insert(posToAddLinebreak, "<br>");
		}
	}
	}

	se->translated_preview = transViewToModify;

	if (transViewToModify.length() > m_errorThreshold && (int)countGraphemes(transViewToModify) > m_errorThreshold) {
		std::vector<std::string> newLines = splitString(transViewToModify, "<br>");
		std::ranges::sort(newLines, [&](const std::string& a, const std::string& b)
			{
				return a.length() > b.length();
			});
		for (const auto& [index, newLine] : newLines | std::views::enumerate) {
			if (size_t charCount = countGraphemes(newLine); charCount > m_errorThreshold) {
				m_logger->error("句子[{}](原有{}行)其中的 译文行[{}]超出报错阈值[{}/{}]", se->pre_processed_text, origLinebreakCount + 1, newLine, charCount, m_errorThreshold);
				se->problems.push_back(std::format("第 {} 行超出报错阈值[{}/{}]", index + 1, charCount, m_errorThreshold));
			}
			else {
				break;
			}
		}
	}

	int newLinebreakCount = countSubstring(se->translated_preview, "<br>");
	se->other_info["换行修复"] = std::format("原文 {} 行, 译文 {} 行, 修正后 {} 行", origLinebreakCount + 1, transLinebreakCount + 1, newLinebreakCount + 1);
	m_logger->debug("句子[{}]({}行): 修正后译文[{}]({}行)", origTransPreview, transLinebreakCount + 1, se->translated_preview, newLinebreakCount + 1);
}

